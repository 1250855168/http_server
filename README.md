# 												HTTP_SERVER



## oop 封装 

- Acceptor:
  - 当接受到新的连接时，将调用 `acceptConnection` 函数。它为接受的客户端连接创建一个新的 `Socket` 对象，获取客户端的地址信息，使用 `Logger` 对象记录连接详情，将接受的套接字设置为非阻塞模式，并调用 `newConnectionCallback` 函数，将接受的套接字作为参数传递。最后，删除为 `clnt_addr` 对象分配的内存
- Buffer:
  - 缓冲区类提供了对字符数据的存储、追加、获取和清空等基本操作，方便在程序中管理和处理字符数据
- Channel
  -  `Channel` 类的作用是封装了事件通道的管理和处理，包括设置事件类型、注册回调函数、处理事件等操作。它与事件循环（`EventLoop`）一起使用，用于实现事件驱动的程序逻辑
- Connection
  - 这个 `Connection` 类的作用是管理与客户端的连接，处理读取和发送数据的操作，并提供相关的回调函数。它与事件循环（`EventLoop`）和套接字（`Socket`）一起使用，用于实现与客户端的通信和处理逻辑
- Epoll
  - `Epoll` 类的作用是封装 epoll 实例的管理和事件轮询的操作。它通过 `poll` 函数等待事件的发生，并将就绪的事件保存到 `activeChannels` 中。通过 `updateChannel` 函数可以添加、修改或删除事件通道。它与事件循环（`EventLoop`）和事件通道（`Channel`）一起使用，用于实现事件驱动的程序逻辑
- EventLoop
  - `EventLoop` 类的作用是表示事件循环，它使用 `Epoll` 对象来进行事件轮询，并使用 `ThreadPool` 对象来处理事件的回调函数。通过 `loop` 函数不断循环执行事件循环的逻辑，通过 `updateChannel` 函数更新事件通道的状态，通过 `addThread` 函数向线程池中添加任务。它是事件驱动程序的核心部分，用于管理事件的触发和处理
- Http_request
  - 
- InetAddress
  - 提供了基本的网络地址操作功能，特别是与 IPv4 地址相关的操作
- Logger
  - 记录日志消息，并根据指定的日志级别决定是否记录该条日志。
  - 可以设置日志级别，控制记录哪些级别以上的日志。
  - 可以将日志写入到指定的日志文件中。
  - 支持批量写入已积累的日志记录，并在积累的日志数量达到一定阈值时进行批量写入操作。
  - 提供获取当前时间戳
- Server
  - 接受新的连接请求，并创建相应的 `Connection` 对象来处理连接。
  - 当连接关闭时，从连接列表中删除对应的 `Connection` 对象，并关闭套接字文件描述符。
  - 通过使用互斥锁 `mutex` 和静态成员变量 `instance` 实现了单例模式和线程安全，确保在多线程环境下只有一个 `Server` 实例被创建
- Socket
  - 创建套接字对象，并提供了构造函数和析构函数来管理套接字资源的创建和释放。
  - 提供了绑定套接字到指定地址、监听套接字、设置套接字为非阻塞模式等功能，用于在服务器端创建和配置套接字。
  - 提供了接受连接请求、连接到指定地址等功能，用于在客户端和服务器端进行连接的建立和操作。
  - 提供了获取套接字文件描述符的方法，方便其他组件使用套接字进行数据传输等操作
- ThreadPool
  - 线程池实现了任务队列、线程同步和异常处理等功能，可以安全地处理并发任务，并提供了获取任务执行结果的能力
- util
  - 它打印错误信息并终止程序，以提醒开发者和用户发生了错误，并停止进一步的执行



## epoll 高并发事件驱动实现 



1. **基于事件驱动模型**：`epoll` 是基于事件驱动的机制，它允许应用程序注册感兴趣的事件，而不需要进行轮询或阻塞式的等待。当有事件发生时，`epoll` 会通知应用程序进行相应的处理。这种事件驱动模型避免了无效的轮询，提高了系统的效率和响应速度。
2. **支持大量的并发连接**：`epoll` 使用了红黑树（Red-Black Tree）和事件链表（Event List）两种数据结构来管理大量的文件描述符。它能够高效地处理大规模的并发连接，而不会因为文件描述符数量增加而导致性能下降。
3. **较低的资源消耗**：`epoll` 使用的是事件驱动模型，相对于传统的轮询机制，它不需要消耗大量的 CPU 时间来遍历和检查每个文件描述符的状态。同时，`epoll` 采用了边缘触发（Edge-Triggered）的方式，只在状态发生变化时才通知应用程序，避免了不必要的通知和处理。
4. **高效的事件就绪通知**：`epoll` 提供了 `epoll_wait` 函数，它会一直阻塞直到有事件发生或超时。相比于传统的轮询方式，这种就绪通知机制避免了不断轮询的开销，只在有事件到达时才唤醒应用程序，提高了系统的效率



##  线程池搭建 

1. **设计线程池类**：定义一个线程池类，包含必要的成员变量和方法来管理线程池的状态和任务队列。
2. **初始化线程池**：在构造函数中创建指定数量的线程，并将它们启动以接收并执行任务。初始化其他必要的成员变量。
3. **添加任务**：实现一个方法，允许将任务添加到线程池中。该方法应该接受可调用对象和参数，并将任务添加到任务队列中。
4. **任务执行**：在线程函数中，使用循环从任务队列中获取任务并执行。可以使用条件变量或其他同步机制等待任务的到来，并在任务执行完毕后继续等待下一个任务。
5. **线程池管理**：实现线程池的管理方法，例如停止线程池的运行、等待所有线程完成任务并退出等



## valgrind 对内存泄漏处理  智能指针修改



1. 安装 Valgrind：根据操作系统的不同，通过相应的包管理器安装 Valgrind。例如，在 Ubuntu 上可以使用以下命令进行安装：

   ```
   sudo apt-get install valgrind
   ```

2. 编译程序：使用 `-g` 选项编译你的 C++ 程序，以便生成调试信息。例如，使用以下命令编译程序：

   ```
   g++ -g your_program.cpp -o your_program
   ```

3. 运行 Valgrind：使用 Valgrind 运行编译后的程序，并检测内存泄漏。以下是运行 Valgrind 的命令：

   ```
   valgrind --leak-check=full --show-leak-kinds=all ./your_program
   ```

4. 分析结果：Valgrind 将会分析程序的内存使用情况，并输出内存泄漏的相关信息。根据输出的结果，可以定位到内存泄漏的位置和相关信息，以便进行修复

5. `std::shared_ptr`：用于共享拥有对象的所有权，允许多个智能指针共享同一个对象。当所有的 `std::shared_ptr` 都释放了对象时，对象会自动被销毁。

   ```cpp
   std::shared_ptr<int> ptr = std::make_shared<int>()
   ```

6. `std::unique_ptr`：用于独占拥有对象的所有权，不允许多个智能指针共享同一个对象。当 `std::unique_ptr` 被销毁时，它所拥有的对象也会被销毁

7. ```cpp
   std::unique_ptr<int> ptr(new int(42));
   ```

   

## log 处理

1. **记录有意义的日志消息** :时间
2. **使用适当的日志输出**：控制台 文件
3. **确定日志级别**：DEBUG、INFO、WARN、ERROR



